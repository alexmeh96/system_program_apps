use std::ffi::CString;
use nix::sys::wait::waitpid;
use nix::unistd::{close, execvp, fork, ForkResult};
use nix::fcntl::{open, OFlag};
use nix::sys::stat::Mode;

fn main() {
    // создание копии текущего процесса.(Создастся полная копия текущего процесса и продолжает выполнение кода с текущего места)
    let fork_result = unsafe { fork().unwrap() };

    // каждый из двух процессов при выполнении кода доходит до этого места
    match fork_result {
        // родительский процесс будет выполнять этот участок кода, т.к. при форке в fork_result ему вернётся Parent
        ForkResult::Parent { child } => {
            // ждём выполнения дочернего процесса
            waitpid(child, None).unwrap();
        }
        // новый процесс будет выполнять этот участок кода, т.к при его создании из родительского процесса,
        // новый процесс будет содержать Child в fork_result
        ForkResult::Child => {
            // создаём вектор с c-подобными строками(заканчивающиеся нулевым символом)
            let mut args = Vec::<CString>::new();
            // добовляем прараметры для программы, которую запустит этот процесс
            args.push(CString::new("ls").unwrap());
            args.push(CString::new("-la").unwrap());

            // закрытие дескриптора файла на стандартный поток вывода
            close(1).unwrap();
            // создаём файл result.txt, которому присвоится файловый дескриптор 1(стандартный поток вывода)
            // Присвоится именно этот дескриптор, т.к. выберается самый маленький дескриптор из ссвободных дескрипторов
            // таблицы дескрипторов процесса
            open(
                "result.txt",
                OFlag::O_CREAT | OFlag::O_WRONLY,
                Mode::from_bits_truncate(0o777),
            ).unwrap();

            // выполнить программу "ls -la", вывод результата который будет записан в стандартный поток вывода(дескриптор 1),
            // а у нас этот дескриптор ссылается на файл result.txt
            // Будет запущен новы процесс выполняющий ls, а текущий процесс прекратит своё выполнение,
            // т.е. команда заменит текущий образ процесса новым, при этом pid нового процесса останется таким же
            execvp(
                &CString::new("ls").unwrap(),
                args.as_slice(),
            ).unwrap();

            // этот код не выполниться, т.к. выше текущий процесс прекратит свою работ(произойдёт замена процесса новым)
            println!("not executed!")
        }
    }

    // этот код выполниться после того, как закончит своё выполнение программа ls
    println!("finish")
}
